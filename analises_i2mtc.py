# -*- coding: utf-8 -*-
"""analises_i2mtc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uf8rZHLnedNUKFnBYzXV4qO7hn6gOOTd
"""

import pandas as pd
import os

import numpy as np
import pandas as pd
import seaborn as sns
from scipy import stats
from google.colab import drive
import matplotlib.pyplot as plt
from lightgbm import LGBMRegressor
from sklearn.utils import resample
from sklearn.model_selection import TimeSeriesSplit
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

'''
# Montar o Google Drive para acessar os arquivos
drive.mount('/content/drive')

# Carregar dados do arquivo CSV
#file_path = '/content/drive/MyDrive/Mestrado/metrics_results/metrics_results_w7784.csv'  # Substitua pelo caminho do seu arquivo
#dt = pd.read_csv(file_path)  # Certifique-se de que o √≠ndice seja carregado como uma coluna
'''

'''
# Caminho para o arquivo CSV
file_path = '/content/drive/MyDrive/Mestrado/metrics_results03/metrics_results_03_w7784.csv'
dt = pd.read_csv(file_path)

# Nome do m√©todo que deseja extrair (exemplo: 'Full Conformal')
method_name = 'Full Conformal'  # Substitua pelo m√©todo desejado

# Selecionar diretamente as linhas pelas posi√ß√µes para RMSE (3), R¬≤ (4) e MAE (5)
# Como as m√©tricas est√£o em ordem e sabemos que RMSE est√° na linha 3, R¬≤ na 4, e MAE na 5
metrics_df = pd.DataFrame({
    'RMSE': eval(dt[method_name].iloc[3]),  # Linha 3 para RMSE
    'R2': eval(dt[method_name].iloc[4]),    # Linha 4 para R¬≤
    'MAE': eval(dt[method_name].iloc[5])    # Linha 5 para MAE
})

# Visualizar as primeiras linhas para verificar o resultado
print(metrics_df.head())

# Opcional: Salvar o DataFrame resultante em um novo arquivo CSV
output_path = '/content/drive/MyDrive/Mestrado/metrics_results03/model_results_03_w7784.csv'
metrics_df.to_csv(output_path, index=False)

import matplotlib.pyplot as plt

# Gerar box-plots para as m√©tricas extra√≠das
plt.figure(figsize=(12, 6))

# Criar um subplot para cada m√©trica
plt.subplot(1, 3, 1)
plt.boxplot(metrics_df['RMSE'])
plt.title('Box-Plot de RMSE')
plt.ylabel('Valor')

plt.subplot(1, 3, 2)
plt.boxplot(metrics_df['R2'])
plt.title('Box-Plot de R¬≤')
plt.ylabel('Valor')

plt.subplot(1, 3, 3)
plt.boxplot(metrics_df['MAE'])
plt.title('Box-Plot de MAE')
plt.ylabel('Valor')

# Ajustar layout
plt.tight_layout()
plt.show()
'''

"""BOX-PLOTS RMSE POR JANELA"""

### upload arquivo
from google.colab import files
uploaded = files.upload()

# Colunas de interesse para o boxplot
colunas_de_interesse = ['SW100', 'SW150', 'SW190', 'SW250', 'SW360', 'SW720']  # Ajuste se necess√°rio

# Verificar se as colunas existem no DataFrame
for col in colunas_de_interesse:
    if col not in df.columns:
        raise ValueError(f"A coluna {col} n√£o foi encontrada no arquivo Excel.")

from google.colab import files
import matplotlib.pyplot as plt
import seaborn as sns

# Paleta de cores pastel do Seaborn
palette = sns.color_palette("pastel", len(colunas_de_interesse))  # Uma cor para cada coluna

# Configurar o estilo do gr√°fico
plt.rcParams.update({
    "font.family": "serif",
    "axes.edgecolor": "black",
    "axes.linewidth": 1.2,
    "axes.grid": True,
    "grid.color": "gray",
    "grid.alpha": 0.5,
    "grid.linestyle": "--",
    "grid.linewidth": 0.5,
    "font.size": 12,
    "text.usetex": False  # Desativar o uso de LaTeX
})

# Gerar o boxplot
fig, ax = plt.subplots(figsize=(7.16, 4))
box = df[colunas_de_interesse].boxplot(ax=ax, patch_artist=True, return_type='dict')

# Aplicar a paleta pastel √†s caixas
for patch, color in zip(box['boxes'], palette):
    patch.set_facecolor(color)

# Personalizar as propriedades restantes
for whisker in box['whiskers']:
    whisker.set(color="black", linewidth=1.2)
for cap in box['caps']:
    cap.set(color="black", linewidth=1.2)
for median in box['medians']:
    median.set(color="orange", linewidth=1.5)

# Adicionar t√≠tulo e r√≥tulos
ax.set_xlabel('Window Size', fontsize=16)
ax.set_ylabel('RMSE (t/h)', fontsize=16)
ax.tick_params(axis='both', which='major', labelsize=10, width=1)

# Salvar o gr√°fico como PDF antes de exibir
plt.savefig('boxplot_window_size.pdf', format='pdf', bbox_inches='tight')

# Exibir o gr√°fico
plt.show()

# Fazer o download do arquivo PDF
files.download('boxplot_window_size.pdf')

"""BOX-PLOTS MAE POR JANELA"""

### upload arquivo
from google.colab import files
uploaded = files.upload()

df = pd.read_excel('MAE_RESULTS.xlsx')
df

# Colunas de interesse para o boxplot
colunas_de_interesse = ['SW100', 'SW150', 'SW190', 'SW250', 'SW360', 'SW720']  # Ajuste se necess√°rio

# Verificar se as colunas existem no DataFrame
for col in colunas_de_interesse:
    if col not in df.columns:
        raise ValueError(f"A coluna {col} n√£o foi encontrada no arquivo Excel.")

from google.colab import files
import matplotlib.pyplot as plt
import seaborn as sns

# Paleta de cores pastel do Seaborn
palette = sns.color_palette("pastel", len(colunas_de_interesse))  # Uma cor para cada coluna

# Configurar o estilo do gr√°fico
plt.rcParams.update({
    "font.family": "serif",
    "axes.edgecolor": "black",
    "axes.linewidth": 1.2,
    "axes.grid": True,
    "grid.color": "gray",
    "grid.alpha": 0.5,
    "grid.linestyle": "--",
    "grid.linewidth": 0.5,
    "font.size": 12,
    "text.usetex": False  # Desativar o uso de LaTeX
})

# Gerar o boxplot
fig, ax = plt.subplots(figsize=(7.16, 4))
box = df[colunas_de_interesse].boxplot(ax=ax, patch_artist=True, return_type='dict')

# Aplicar a paleta pastel √†s caixas
for patch, color in zip(box['boxes'], palette):
    patch.set_facecolor(color)

# Personalizar as propriedades restantes
for whisker in box['whiskers']:
    whisker.set(color="black", linewidth=1.2)
for cap in box['caps']:
    cap.set(color="black", linewidth=1.2)
for median in box['medians']:
    median.set(color="orange", linewidth=1.5)

# Adicionar t√≠tulo e r√≥tulos
ax.set_xlabel('Window Size', fontsize=16)
ax.set_ylabel('MAE (t/h)', fontsize=16)
ax.tick_params(axis='both', which='major', labelsize=10, width=1)

# Salvar o gr√°fico como PDF antes de exibir
plt.savefig('boxplot_window_size.pdf', format='pdf', bbox_inches='tight')

# Exibir o gr√°fico
plt.show()

# Fazer o download do arquivo PDF
files.download('boxplot_window_size.pdf')

"""
SHAPIRO-WILK TEST para verificar a normalidade Dados de Cobertura
"""

### upload arquivo
from google.colab import files
uploaded = files.upload()

import os

# Remover o arquivo antigo, se ainda existir
if os.path.exists("cobertura_results.xlsx"):
    os.remove("cobertura_results.xlsx")

from google.colab import files
uploaded = files.upload()  # Refa√ßa o upload do arquivo atualizado

df = pd.read_excel('cobertura_results.xlsx')
df

from scipy.stats import shapiro

# Selecionar as colunas desejadas como uma lista
columns = ['T-Student', 'Full', 'Bootstrap', 'Split']

# Iterar sobre cada coluna e aplicar o teste Shapiro-Wilk
for column in columns:
    data = df[column]  # Selecionar os dados da coluna
    stat, p_value = shapiro(data)
    print(f"Coluna: {column}")
    print(f"Estat√≠stica do teste: {stat}")
    print(f"P-valor: {p_value}")
    if p_value > 0.05:
        print("N√£o rejeitamos a hip√≥tese nula: os dados seguem uma distribui√ß√£o normal.\n")
    else:
        print("Rejeitamos a hip√≥tese nula: os dados n√£o seguem uma distribui√ß√£o normal.\n")

""" ANOVA para Comparar Todos os Grupos:"""

from scipy.stats import f_oneway

# Teste ANOVA
stat, p_value = f_oneway(
    df['T-Student'],
    df['Full'],
    df['Bootstrap'],
    df['Split']
)

print(f"F-statistic: {stat}")
print(f"P-value: {p_value}")

if p_value < 0.05:
    print("Rejeitamos a hip√≥tese nula: existe diferen√ßa significativa entre os grupos.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° diferen√ßa significativa entre os grupos.")

"""Hip√≥tese Nula (
ùêª
0
H
0
‚Äã
 ):

ùêª
0
H
0
‚Äã
 : As m√©dias dos grupos s√£o iguais.
Hip√≥tese Alternativa (
ùêª
ùëé
H
a
‚Äã
 ):

ùêª
ùëé
H
a
‚Äã
 : Pelo menos um grupo tem uma m√©dia significativamente diferente.
Decis√£o: Rejeitamos a hip√≥tese nula (
ùêª
0
H
0
‚Äã
 ), pois o
ùëù
p-valor √© muito menor que 0.05.

Conclus√£o: Existe uma diferen√ßa estatisticamente significativa entre as m√©dias dos grupos.

Para identificar quais grupos diferem entre si, √© necess√°rio realizar testes post-hoc, como o Tukey HSD (Honest Significant Difference)
"""

from statsmodels.stats.multicomp import pairwise_tukeyhsd

# Organizar os dados em formato longo
import pandas as pd
data_long = pd.melt(df.reset_index(), id_vars=['index'], value_vars=['T-Student', 'Full', 'Bootstrap', 'Split'])
data_long.columns = ['Index', 'Method', 'Coverage']

# Aplicar o teste Tukey HSD
tukey = pairwise_tukeyhsd(endog=data_long['Coverage'], groups=data_long['Method'], alpha=0.05)

# Exibir os resultados
print(tukey)

"""O teste Tukey HSD confirma que:

Existem diferen√ßas estatisticamente significativas entre a maioria dos pares de m√©todos, exceto entre Full_Cobertura e Split_Cobertura, onde n√£o h√° evid√™ncias para rejeitar a igualdade das m√©dias.


O Bootstrap_Cobertura parece diferir significativamente de todos os outros m√©todos, refor√ßando sua distin√ß√£o como potencialmente melhor.
"""

from statsmodels.stats.multicomp import MultiComparison
import matplotlib.pyplot as plt

# Configurar os dados para o teste
mc = MultiComparison(data_long['Coverage'], data_long['Method'])
tukey_result = mc.tukeyhsd(alpha=0.05)

# Plotar o gr√°fico de compara√ß√µes Tukey
fig = tukey_result.plot_simultaneous(comparison_name='T-Student', figsize=(8, 6))
plt.title('Tukey HSD Confidence Intervals')
plt.xlabel('Mean Difference')
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

import numpy as np
import pandas as pd
import seaborn as sns

# Criar matriz de valores p ajustados (baseado no resultado do Tukey)
p_values_matrix = pd.DataFrame(
    tukey_result._results_table.data[1:],
    columns=tukey_result._results_table.data[0]
)

# Filtrar apenas os valores p e criar um heatmap
p_values = p_values_matrix.pivot(index='group1', columns='group2', values='p-adj')

plt.figure(figsize=(8, 6))
sns.heatmap(p_values, annot=True, fmt=".3f", cmap="coolwarm", cbar=True)
plt.title('P-value Matrix (Tukey HSD)')
plt.show()

# Plotar o violin plot
plt.figure(figsize=(8, 6))
sns.violinplot(x='Method', y='Coverage', data=data_long, palette='muted')

# Ajustar o gr√°fico
plt.title('Coverage Distributions by Method', fontsize=14)
plt.xlabel('Method', fontsize=12)
plt.ylabel('Coverage', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

"""SHAPIRO-WILK TEST para verificar a normalidade Dados de Largura"""

### upload arquivo
from google.colab import files
uploaded = files.upload()

df = pd.read_excel('largura_results.xlsx')
df

from scipy.stats import shapiro

# Selecionar as colunas desejadas como uma lista
columns = ['T-Student', 'Full', 'Bootstrap', 'Split']

# Iterar sobre cada coluna e aplicar o teste Shapiro-Wilk
for column in columns:
    data = df[column]  # Selecionar os dados da coluna
    stat, p_value = shapiro(data)
    print(f"Coluna: {column}")
    print(f"Estat√≠stica do teste: {stat}")
    print(f"P-valor: {p_value}")
    if p_value > 0.05:
        print("N√£o rejeitamos a hip√≥tese nula: os dados seguem uma distribui√ß√£o normal.\n")
    else:
        print("Rejeitamos a hip√≥tese nula: os dados n√£o seguem uma distribui√ß√£o normal.\n")

"""ANOVA para Comparar Todos os Grupos:"""

from scipy.stats import f_oneway

# Teste ANOVA
stat, p_value = f_oneway(
    df['T-Student'],
    df['Full'],
    df['Bootstrap'],
    df['Split']
)

print(f"F-statistic: {stat}")
print(f"P-value: {p_value}")

if p_value < 0.05:
    print("Rejeitamos a hip√≥tese nula: existe diferen√ßa significativa entre os grupos.")
else:
    print("N√£o rejeitamos a hip√≥tese nula: n√£o h√° diferen√ßa significativa entre os grupos.")

from statsmodels.stats.multicomp import pairwise_tukeyhsd

# Organizar os dados em formato longo
import pandas as pd
data_long = pd.melt(df.reset_index(), id_vars=['index'], value_vars=['T-Student', 'Full', 'Bootstrap', 'Split'])
data_long.columns = ['Index', 'Method', 'Mean Width']

# Aplicar o teste Tukey HSD
tukey = pairwise_tukeyhsd(endog=data_long['Mean Width'], groups=data_long['Method'], alpha=0.05)

# Exibir os resultados
print(tukey)

from statsmodels.stats.multicomp import MultiComparison
import matplotlib.pyplot as plt

# Configurar os dados para o teste
mc = MultiComparison(data_long['Mean Width'], data_long['Method'])
tukey_result = mc.tukeyhsd(alpha=0.05)

# Plotar o gr√°fico de compara√ß√µes Tukey
fig = tukey_result.plot_simultaneous(comparison_name='T-Student', figsize=(8, 6))
plt.title('Tukey HSD Confidence Intervals')
plt.xlabel('Mean Difference')
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

import numpy as np
import pandas as pd
import seaborn as sns

# Criar matriz de valores p ajustados (baseado no resultado do Tukey)
p_values_matrix = pd.DataFrame(
    tukey_result._results_table.data[1:],
    columns=tukey_result._results_table.data[0]
)

# Filtrar apenas os valores p e criar um heatmap
p_values = p_values_matrix.pivot(index='group1', columns='group2', values='p-adj')

plt.figure(figsize=(8, 6))
sns.heatmap(p_values, annot=True, fmt=".3f", cmap="coolwarm", cbar=True)
plt.title('P-value Matrix (Tukey HSD)')
plt.show()

# Plotar o violin plot
plt.figure(figsize=(8, 6))
sns.violinplot(x='Method', y='Mean Width', data=data_long, palette='muted')

# Ajustar o gr√°fico
plt.title('Coverage Distributions by Method', fontsize=14)
plt.xlabel('Method', fontsize=12)
plt.ylabel('Mean Width', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()